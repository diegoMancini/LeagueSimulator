package scala.australExercises.exercise3;

/**
 * Created by DiegoMancini on 22/2/17.
 */
public class Enun2 {

/*
1.	Diferencias entre clase abstracta e interfaz:
Una interfaz tiene como característica principal que todos sus métodos son abstractos (son métodos declarados, pero no tienen comportamiento). Esto conlleva a que cuando una clase implemente una interfaz, esta está obligada a tener todos los métodos de la interfaz dentro, dándole un comportamiento a cada una. En cambio, la clase abstracta no está obligada a tener todos sus métodos abstractos, entonces la subclase no está obligada a tenerlos dentro ni a darle un comportamiento.
Otra diferencia es que una clase puede implementar cuantas interfaces quiera, mientras que solo puede tener una superclase.
Una similitud entre ambas es que ambas pueden ser utilizadas para implementar polimorfismo.

2.	Polimorfismo (Que es y para qué sirve):
El polimorfismo describe un patrón en OOP en donde dos clases diferentes comparten uno o más mensajes con el mismo nombre, pero cada clase la utiliza con un comportamiento diferente.
Se utiliza para programar objetos con características comunes y que todos compartan esas características, mientas que cada una le da un uso diferente. (Ej.: un botón).

3.	¿Qué es lo que se busca al programar bajo OOP?:
Al programar bajo el paradigma de OOP, se busca acercarse a la realidad, ya que bajo este paradigma definimos a un ente de la realidad como un objeto, siendo su concepto la clase que lo crea. Cada variable de instancia sería una propiedad o una característica del ente, mientras que los métodos serían las funciones o los comportamientos de este.

4.	¿Cuáles son las diferencias y semejanzas entre this y super?:
La diferencia principal seria que this busca el método en la clase que genero al objeto, mientras que super busca el método en la superclase de la clase que genero al objeto.
Las semejanzas más importantes entre this y super serían: primero, aunque una busca en la clase y la otra lo busca en la superclase, ambas toman como contexto el objeto donde están parados (donde se ejecuta el mensaje). Segundo, es que ambas son consideradas pseudo-variables.

5.	¿Hay inconvenientes con el uso de null y de setters?:
Se considera como ineficiente el uso de null, ya que al utilizarlo no solo provoca el uso de reiterados if’s, sino que también lleva a tener que tener mucho cuidado a la hora de utilizar el objeto que tiene el null ya que podría llevar a un NullPointerException.
El uso de setters tampoco es recomendable, ya que el cambio de un estado dentro del objeto puede llevar a generar otros cambios no deseados dentro del objeto. El uso de setters lleva a la obviacion de cambios importantes dentro del objeto que son necesarios para la coherencia del mismo.


Date fija:

SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
Date d = sdf.parse("21/12/2012")
 */




}
